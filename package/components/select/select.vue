<template>
  <el-select
    ref="inputRef"
    v-model="inputValue"
    class="k-select"
    v-bind="attrs"
    default-first-option
    :style="{
      width: props.width
    }"
    @change="handleChangeEvent"
    @focus="handleFocusEvent"
    @blur="handleBlurEvent"
    @clear="handleClearEvent"
    @visible-change="handleVisibleChangeEvent"
    @remove-tag="handleRemoveTagEvent"
  >
    <slot></slot>
    <template v-if="slots.tag" #tag>
      <slot v-if="slots.tag" name="tag"></slot>
    </template>
    <template v-if="slots.empty" #empty>
      <slot name="empty"></slot>
    </template>
    <template v-if="slots.header" #header>
      <slot name="header"></slot>
    </template>
    <template v-if="slots.footer" #footer>
      <slot name="footer"></slot>
    </template>
  </el-select>
</template>

<script setup lang="ts">
import { ref, computed, watch } from 'vue';
import { SelectInputProps } from './type';
import { getCompSize } from '../../utils';

defineOptions({
  name: 'KSelect'
});

type InputValue = string | number;

const props = withDefaults(defineProps<SelectInputProps>(), {
  teleported: true,
  valueKey: 'value',
  multipleLimit: 0,
  autocomplete: 'off',
  persistent: true

});

const emits = defineEmits([
  'update:modelValue',
  'blur',
  'change',
  'clear',
  'focus',
  'visible-change',
  'remove-tag'
]);

const slots = defineSlots();

const inputValue = ref<InputValue>('');
const inputRef = ref<any>(null);

const attrs = computed(() => ({
  disabled: props.disabled,
  placeholder: props.placeholder,
  clearable: props.clearable,
  multiple: props.multiple,
  filterable: props.filterable,
  allowCreate: props.allowCreate,
  popperClass: props.popperClass,
  teleported: props.teleported,
  valueKey: props.valueKey,
  collapseTags: props.collapseTags,
  collapseTagsTooltip: props.collapseTagsTooltip,
  multipleLimit: props.multipleLimit,
  autocomplete: props.autocomplete,
  filterMethod: props.filterMethod,
  remote: props.remote,
  remoteMethod: props.remoteMethod,
  remoteShowSuffix: props.remoteShowSuffix,
  loading: props.loading,
  loadingText: props.loadingText,
  noMatchText: props.noMatchText,
  noDataText: props.noDataText,
  defaultFirstOption: props.defaultFirstOption,
  fitInputWidth: props.fitInputWidth,
  suffixIcon: props.suffixIcon,
  name: props.name,
  automaticDropdown: props.automaticDropdown,
  persistent: props.persistent,
  size: getCompSize(props.size)
}));

watch(() => props.modelValue, (newValue) => {
  inputValue.value = newValue;
}, { immediate: true });

function handleBlurEvent() {
  emits('blur');
}
function handleFocusEvent() {
  emits('focus');
}
function handleChangeEvent(value:InputValue) {
  emits('update:modelValue', value);
  emits('change', value);
}
function handleClearEvent() {
  emits('update:modelValue', '');
  emits('clear', '');
  emits('change', '');
}
function handleVisibleChangeEvent(value:boolean) {
  emits('visible-change', value);
}
function handleRemoveTagEvent(tag:any) {
  emits('remove-tag', tag);
}
function focus() {
  inputRef.value?.focus();
}
function blur() {
  inputRef.value?.blur();
}

defineExpose({
  focus,
  blur
});
</script>

<style lang="less">
@import './style.less';
</style>